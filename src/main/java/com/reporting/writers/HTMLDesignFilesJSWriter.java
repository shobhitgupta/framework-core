package com.reporting.writers;

import java.io.FileNotFoundException;
import java.io.PrintWriter;

import com.reporting.enums.Colors;
import com.reporting.enums.ReportLabels;
import com.reporting.utils.Directory;

public class HTMLDesignFilesJSWriter {
    private static String reduceData(String paramString, int paramInt) {
        int i = 0;
        for (int j = 0; j < paramString.length(); j++) {
            if (paramString.charAt(j) == ',') {
                i++;
                if (i == paramInt) {
                    paramString = paramString.substring(j + 1, paramString.length());
                }
            }
        }
        return paramString;
    }

    public static void tableFilterJS() {
        try {
            PrintWriter localPrintWriter = new PrintWriter(Directory.JSDir + Directory.SEP + "tablefilter.js");
            localPrintWriter.println(
                    "/*====================================================\n\t- HTML Table Filter Generator v1.6\n\t- By Max Guglielmi\n\t- mguglielmi.free.fr/scripts/TableFilter/?l=en\n\t- please do not change this comment\n\t- don\'t forget to give some credit... it\'s always\n\tgood for the author\n\t- Special credit to Cedric Wartel and \n\tcnx.claude@free.fr for contribution and \n\tinspiration\n=====================================================*/\n\n// global vars\nvar TblId, SearchFlt, SlcArgs;\nTblId = new Array(), SlcArgs = new Array();\n\n\nfunction setFilterGrid(id)\n/*====================================================\n\t- Checks if id exists and is a table\n\t- Then looks for additional params \n\t- Calls fn that generates the grid\n=====================================================*/\n{\t\n\tvar tbl = grabEBI(id);\n\tvar ref_row, fObj;\n\tif(tbl != null && tbl.nodeName.toLowerCase() == \"table\")\n\t{\t\t\t\t\t\t\n\t\tif(arguments.length>1)\n\t\t{\n\t\t\tfor(var i=0; i<arguments.length; i++)\n\t\t\t{\n\t\t\t\tvar argtype = typeof arguments[i];\n\t\t\t\t\n\t\t\t\tswitch(argtype.toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\tref_row = arguments[i];\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\t\tfObj = arguments[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}//switch\n\t\t\t\t\t\t\t\n\t\t\t}//for\n\t\t}//if\n\t\t\n\t\tref_row == undefined ? ref_row=2 : ref_row=(ref_row+2);\n\t\tvar ncells = getCellsNb(id,ref_row);\n\t\ttbl.tf_ncells = ncells;\n\t\tif(tbl.tf_ref_row==undefined) tbl.tf_ref_row = ref_row;\n\t\ttbl.tf_Obj = fObj;\n\t\tif( !hasGrid(id) ) AddGrid(id);\t\t\n\t}//if tbl!=null\n}\n\nfunction AddGrid(id)\n/*====================================================\n\t- adds a row containing the filtering grid\n=====================================================*/\n{\t\n\tTblId.push(id);\n\tvar t = grabEBI(id);\n\tvar f = t.tf_Obj, n = t.tf_ncells;\t\n\tvar inpclass, fltgrid, displayBtn, btntext, enterkey;\n\tvar modfilter_fn, display_allText, on_slcChange;\n\tvar displaynrows, totrows_text, btnreset, btnreset_text;\n\tvar sort_slc, displayPaging, pagingLength, displayLoader;\n\tvar load_text, exactMatch, alternateBgs, colOperation;\n\tvar rowVisibility, colWidth, bindScript;\n\t\n\tf!=undefined && f[\"grid\"]==false ? fltgrid=false : fltgrid=true;//enables/disables filter grid\n\tf!=undefined && f[\"btn\"]==true ? displayBtn=true : displayBtn=false;//show/hides filter\'s validation button\n\tf!=undefined && f[\"btn_text\"]!=undefined ? btntext=f[\"btn_text\"] : btntext=\"go\";//defines button text\n\tf!=undefined && f[\"enter_key\"]==false ? enterkey=false : enterkey=true;//enables/disables enter key\n\tf!=undefined && f[\"mod_filter_fn\"] ? modfilter_fn=true : modfilter_fn=false;//defines alternative fn\n\tf!=undefined && f[\"display_all_text\"]!=undefined ? display_allText=f[\"display_all_text\"] : display_allText=\"\";//defines 1st option text\n\tf!=undefined && f[\"on_change\"]==false ? on_slcChange=false : on_slcChange=true;//enables/disables onChange event on combo-box \n\tf!=undefined && f[\"rows_counter\"]==true ? displaynrows=true : displaynrows=false;//show/hides rows counter\n\tf!=undefined && f[\"rows_counter_text\"]!=undefined ? totrows_text=f[\"rows_counter_text\"] : totrows_text=\"Displayed rows: \";//defines rows counter text\n\tf!=undefined && f[\"btn_reset\"]==true ? btnreset=true : btnreset=false;//show/hides reset link\n\tf!=undefined && f[\"btn_reset_text\"]!=undefined ? btnreset_text=f[\"btn_reset_text\"] : btnreset_text=\"Reset\";//defines reset text\n\tf!=undefined && f[\"sort_select\"]==true ? sort_slc=true : sort_slc=false;//enables/disables select options sorting\n\tf!=undefined && f[\"paging\"]==true ? displayPaging=true : displayPaging=false;//enables/disables table paging\n\tf!=undefined && f[\"paging_length\"]!=undefined ? pagingLength=f[\"paging_length\"] : pagingLength=10;//defines table paging length\n\tf!=undefined && f[\"loader\"]==true ? displayLoader=true : displayLoader=false;//enables/disables loader\n\tf!=undefined && f[\"loader_text\"]!=undefined ? load_text=f[\"loader_text\"] : load_text=\"Loading...\";//defines loader text\n\tf!=undefined && f[\"exact_match\"]==true ? exactMatch=true : exactMatch=false;//enables/disbles exact match for search\n\tf!=undefined && f[\"alternate_rows\"]==true ? alternateBgs=true : alternateBgs=false;//enables/disbles rows alternating bg colors\n\tf!=undefined && f[\"col_operation\"] ? colOperation=true : colOperation=false;//enables/disbles column operation(sum,mean)\n\tf!=undefined && f[\"rows_always_visible\"] ? rowVisibility=true : rowVisibility=false;//makes a row always visible\n\tf!=undefined && f[\"col_width\"] ? colWidth=true : colWidth=false;//defines widths of columns\n\tf!=undefined && f[\"bind_script\"] ? bindScript=true : bindScript=false;\n\t\n\t// props are added to table in order to be easily accessible from other fns\n\tt.tf_fltGrid\t\t\t=\tfltgrid;\n\tt.tf_displayBtn\t\t\t= \tdisplayBtn;\n\tt.tf_btnText\t\t\t=\tbtntext;\n\tt.tf_enterKey\t\t\t= \tenterkey;\n\tt.tf_isModfilter_fn\t\t= \tmodfilter_fn;\n\tt.tf_display_allText \t= \tdisplay_allText;\n\tt.tf_on_slcChange \t\t= \ton_slcChange;\n\tt.tf_rowsCounter \t\t= \tdisplaynrows;\n\tt.tf_rowsCounter_text\t= \ttotrows_text;\n\tt.tf_btnReset \t\t\t= \tbtnreset;\n\tt.tf_btnReset_text \t\t= \tbtnreset_text;\n\tt.tf_sortSlc \t\t\t=\tsort_slc;\n\tt.tf_displayPaging \t\t= \tdisplayPaging;\n\tt.tf_pagingLength \t\t= \tpagingLength;\n\tt.tf_displayLoader\t\t= \tdisplayLoader;\n\tt.tf_loadText\t\t\t= \tload_text;\n\tt.tf_exactMatch \t\t= \texactMatch;\n\tt.tf_alternateBgs\t\t=\talternateBgs;\n\tt.tf_startPagingRow\t\t= \t0;\n\t\n\tif(modfilter_fn) t.tf_modfilter_fn = f[\"mod_filter_fn\"];// used by DetectKey fn\n\n\tif(fltgrid)\n\t{\n\t\tvar fltrow = t.insertRow(0); //adds filter row\n\t\tfltrow.className = \"fltrow\";\n\t\tfor(var i=0; i<n; i++)// this loop adds filters\n\t\t{\n\t\t\tvar fltcell = fltrow.insertCell(i);\n\t\t\t//fltcell.noWrap = true;\n\t\t\ti==n-1 && displayBtn==true ? inpclass = \"flt_s\" : inpclass = \"flt\";\n\t\t\t\n\t\t\tif(f==undefined || f[\"col_\"+i]==undefined || f[\"col_\"+i]==\"none\") \n\t\t\t{\n\t\t\t\tvar inptype;\n\t\t\t\t(f==undefined || f[\"col_\"+i]==undefined) ? inptype=\"text\" : inptype=\"hidden\";//show/hide input\t\n\t\t\t\tvar inp = createElm( \"input\",[\"id\",\"flt\"+i+\"_\"+id],[\"type\",inptype],[\"class\",inpclass] );\t\t\t\t\t\n\t\t\t\tinp.className = inpclass;// for ie<=6\n\t\t\t\tfltcell.appendChild(inp);\n\t\t\t\tif(enterkey) inp.onkeypress = DetectKey;\n\t\t\t}\n\t\t\telse if(f[\"col_\"+i]==\"select\")\n\t\t\t{\n\t\t\t\tvar slc = createElm( \"select\",[\"id\",\"flt\"+i+\"_\"+id],[\"class\",inpclass] );\n\t\t\t\tslc.className = inpclass;// for ie<=6\n\t\t\t\tfltcell.appendChild(slc);\n\t\t\t\tPopulateOptions(id,i);\n\t\t\t\tif(displayPaging)//stores arguments for GroupByPage() fn\n\t\t\t\t{\n\t\t\t\t\tvar args = new Array();\n\t\t\t\t\targs.push(id); args.push(i); args.push(n);\n\t\t\t\t\targs.push(display_allText); args.push(sort_slc); args.push(displayPaging);\n\t\t\t\t\tSlcArgs.push(args);\n\t\t\t\t}\n\t\t\t\tif(enterkey) slc.onkeypress = DetectKey;\n\t\t\t\tif(on_slcChange) \n\t\t\t\t{\n\t\t\t\t\t(!modfilter_fn) ? slc.onchange = function(){ Filter(id); } : slc.onchange = f[\"mod_filter_fn\"];\n\t\t\t\t} \n\t\t\t}\n\t\t\t\n\t\t\tif(i==n-1 && displayBtn==true)// this adds button\n\t\t\t{\n\t\t\t\tvar btn = createElm(\n\t\t\t\t\t\t\t\t\t\t\"input\",\n\t\t\t\t\t\t\t\t\t\t[\"id\",\"btn\"+i+\"_\"+id],[\"type\",\"button\"],\n\t\t\t\t\t\t\t\t\t\t[\"value\",btntext],[\"class\",\"btnflt\"] \n\t\t\t\t\t\t\t\t\t);\n\t\t\t\tbtn.className = \"btnflt\";\n\t\t\t\t\n\t\t\t\tfltcell.appendChild(btn);\n\t\t\t\t(!modfilter_fn) ? btn.onclick = function(){ Filter(id); } : btn.onclick = f[\"mod_filter_fn\"];\t\t\t\t\t\n\t\t\t}//if\t\t\n\t\t\t\n\t\t}// for i\t\t\n\t}//if fltgrid\n\n\tif(displaynrows || btnreset || displayPaging || displayLoader)\n\t{\n\t\t\n\t\t/*** div containing rows # displayer + reset btn ***/\n\t\tvar infdiv = createElm( \"div\",[\"id\",\"inf_\"+id],[\"class\",\"inf\"] );\n\t\tinfdiv.className = \"inf\";// setAttribute method for class attribute doesn\'t seem to work on ie<=6\n\t\tt.parentNode.insertBefore(infdiv, t);\n\t\t\n\t\tif(displaynrows)\n\t\t{\n\t\t\t/*** left div containing rows # displayer ***/\n\t\t\tvar totrows;\n\t\t\tvar ldiv = createElm( \"div\",[\"id\",\"ldiv_\"+id] );\n\t\t\tdisplaynrows ? ldiv.className = \"ldiv\" : ldiv.style.display = \"none\";\n\t\t\tdisplayPaging ? totrows = pagingLength : totrows = getRowsNb(id);\n\t\t\t\n\t\t\tvar totrows_span = createElm( \"span\",[\"id\",\"totrows_span_\"+id],[\"class\",\"tot\"] ); // tot # of rows displayer\n\t\t\ttotrows_span.className = \"tot\";//for ie<=6\n\t\t\ttotrows_span.appendChild( createText(totrows) );\n\t\t\n\t\t\tvar totrows_txt = createText(totrows_text);\n\t\t\tldiv.appendChild(totrows_txt);\n\t\t\tldiv.appendChild(totrows_span);\n\t\t\tinfdiv.appendChild(ldiv);\n\t\t}\n\t\t\n\t\tif(displayLoader)\n\t\t{\n\t\t\t/*** div containing loader  ***/\n\t\t\tvar loaddiv = createElm( \"div\",[\"id\",\"load_\"+id],[\"class\",\"loader\"] );\n\t\t\tloaddiv.className = \"loader\";// for ie<=6\n\t\t\tloaddiv.style.display = \"none\";\n\t\t\tloaddiv.appendChild( createText(load_text) );\t\n\t\t\tinfdiv.appendChild(loaddiv);\n\t\t}\n\t\t\t\t\n\t\tif(displayPaging)\n\t\t{\n\t\t\t/*** mid div containing paging displayer ***/\n\t\t\tvar mdiv = createElm( \"div\",[\"id\",\"mdiv_\"+id] );\n\t\t\tdisplayPaging ? mdiv.className = \"mdiv\" : mdiv.style.display = \"none\";\t\t\t\t\t\t\n\t\t\tinfdiv.appendChild(mdiv);\n\t\t\t\n\t\t\tvar start_row = t.tf_ref_row;\n\t\t\tvar row = grabTag(t,\"tr\");\n\t\t\tvar nrows = row.length;\n\t\t\tvar npages = Math.ceil( (nrows - start_row)/pagingLength );//calculates page nb\n\t\t\t\n\t\t\tvar slcPages = createElm( \"select\",[\"id\",\"slcPages_\"+id] );\n\t\t\tslcPages.onchange = function(){\n\t\t\t\tif(displayLoader) showLoader(id,\"\");\n\t\t\t\tt.tf_startPagingRow = this.value;\n\t\t\t\tGroupByPage(id);\n\t\t\t\tif(displayLoader) showLoader(id,\"none\");\n\t\t\t}\n\t\t\t\n\t\t\tvar pgspan = createElm( \"span\",[\"id\",\"pgspan_\"+id] );\n\t\t\tgrabEBI(\"mdiv_\"+id).appendChild( createText(\" Page \") );\n\t\t\tgrabEBI(\"mdiv_\"+id).appendChild(slcPages);\n\t\t\tgrabEBI(\"mdiv_\"+id).appendChild( createText(\" of \") );\n\t\t\tpgspan.appendChild( createText(npages+\" \") );\n\t\t\tgrabEBI(\"mdiv_\"+id).appendChild(pgspan);\t\n\t\t\t\n\t\t\tfor(var j=start_row; j<nrows; j++)//this sets rows to validRow=true\n\t\t\t{\n\t\t\t\trow[j].setAttribute(\"validRow\",\"true\");\n\t\t\t}//for j\n\t\t\t\n\t\t\tsetPagingInfo(id);\n\t\t\tif(displayLoader) showLoader(id,\"none\");\n\t\t}\n\t\t\n\t\tif(btnreset && fltgrid)\n\t\t{\n\t\t\t/*** right div containing reset button **/\t\n\t\t\tvar rdiv = createElm( \"div\",[\"id\",\"reset_\"+id] );\n\t\t\tbtnreset ? rdiv.className = \"rdiv\" : rdiv.style.display = \"none\";\n\t\t\t\n\t\t\tvar fltreset = createElm( \t\"a\",\n\t\t\t\t\t\t\t\t\t\t[\"href\",\"javascript:clearFilters(\'\"+id+\"\');Filter(\'\"+id+\"\');\"] );\n\t\t\tfltreset.appendChild(createText(btnreset_text));\n\t\t\trdiv.appendChild(fltreset);\n\t\t\tinfdiv.appendChild(rdiv);\n\t\t}\n\t\t\n\t}//if displaynrows etc.\n\t\n\tif(colWidth)\n\t{\n\t\tt.tf_colWidth = f[\"col_width\"];\n\t\tsetColWidths(id);\n\t}\n\t\n\tif(alternateBgs && !displayPaging)\n\t\tsetAlternateRows(id);\n\t\n\tif(colOperation)\n\t{\n\t\tt.tf_colOperation = f[\"col_operation\"];\n\t\tsetColOperation(id);\n\t}\n\t\n\tif(rowVisibility)\n\t{\n\t\tt.tf_rowVisibility = f[\"rows_always_visible\"];\n\t\tif(displayPaging) setVisibleRows(id);\n\t}\n\t\n\tif(bindScript)\n\t{\n\t\tt.tf_bindScript = f[\"bind_script\"];\n\t\tif(\tt.tf_bindScript!=undefined &&\n\t\t\tt.tf_bindScript[\"target_fn\"]!=undefined )\n\t\t{//calls a fn if defined  \n\t\t\tt.tf_bindScript[\"target_fn\"].call(null,id);\n\t\t}\n\t}//if bindScript\n}\n\nfunction PopulateOptions(id,cellIndex)\n/*====================================================\n\t- populates select\n\t- adds only 1 occurence of a value\n=====================================================*/\n{\n\tvar t = grabEBI(id);\n\tvar ncells = t.tf_ncells, opt0txt = t.tf_display_allText;\n\tvar sort_opts = t.tf_sortSlc, paging = t.tf_displayPaging;\n\tvar start_row = t.tf_ref_row;\n\tvar row = grabTag(t,\"tr\");\n\tvar OptArray = new Array();\n\tvar optIndex = 0; // option index\n\tvar currOpt = new Option(opt0txt,\"\",false,false); //1st option\n\tgrabEBI(\"flt\"+cellIndex+\"_\"+id).options[optIndex] = currOpt;\n\t\n\tfor(var k=start_row; k<row.length; k++)\n\t{\n\t\tvar cell = getChildElms(row[k]).childNodes;\n\t\tvar nchilds = cell.length;\n\t\tvar isPaged = row[k].getAttribute(\"paging\");\n\t\t\n\t\tif(nchilds == ncells){// checks if row has exact cell #\n\t\t\t\n\t\t\tfor(var j=0; j<nchilds; j++)// this loop retrieves cell data\n\t\t\t{\n\t\t\t\tif(cellIndex==j)\n\t\t\t\t{\n\t\t\t\t\tvar cell_data = getCellText(cell[j]);\n\t\t\t\t\t// checks if celldata is already in array\n\t\t\t\t\tvar isMatched = false;\n\t\t\t\t\tfor(w in OptArray)\n\t\t\t\t\t{\n\t\t\t\t\t\tif( cell_data == OptArray[w] ) isMatched = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(!isMatched) OptArray.push(cell_data);\n\t\t\t\t}//if cellIndex==j\n\t\t\t}//for j\n\t\t}//if\n\t}//for k\n\t\n\tif(sort_opts) OptArray.sort();\n\tfor(y in OptArray)\n\t{\n\t\toptIndex++;\n\t\tvar currOpt = new Option(OptArray[y],OptArray[y],false,false);\n\t\tgrabEBI(\"flt\"+cellIndex+\"_\"+id).options[optIndex] = currOpt;\t\t\n\t}\n\t\t\n}\n\nfunction Filter(id)\n/*====================================================\n\t- Filtering fn\n\t- gets search strings from SearchFlt array\n\t- retrieves data from each td in every single tr\n\tand compares to search string for current\n\tcolumn\n\t- tr is hidden if all search strings are not \n\tfound\n=====================================================*/\n{\t\n\tshowLoader(id,\"\");\n\tSearchFlt = getFilters(id);\n\tvar t = grabEBI(id);\n\tt.tf_Obj!=undefined ? fprops = t.tf_Obj : fprops = new Array();\n\tvar SearchArgs = new Array();\n\tvar ncells = getCellsNb(id);\n\tvar totrows = getRowsNb(id), hiddenrows = 0;\n\tvar ematch = t.tf_exactMatch;\n\tvar showPaging = t.tf_displayPaging;\n\t\n\tfor(var i=0; i<SearchFlt.length; i++)\n\t\tSearchArgs.push( (grabEBI(SearchFlt[i]).value).toLowerCase() );\n\t\n\tvar start_row = t.tf_ref_row;\n\tvar row = grabTag(t,\"tr\");\n\t\n\tfor(var k=start_row; k<row.length; k++)\n\t{\n\t\t/*** if table already filtered some rows are not visible ***/\n\t\tif(row[k].style.display == \"none\") row[k].style.display = \"\";\n\t\t\n\t\tvar cell = getChildElms(row[k]).childNodes;\n\t\tvar nchilds = cell.length;\n\n\t\tif(nchilds == ncells)// checks if row has exact cell #\n\t\t{\n\t\t\tvar cell_value = new Array();\n\t\t\tvar occurence = new Array();\n\t\t\tvar isRowValid = true;\n\t\t\t\t\n\t\t\tfor(var j=0; j<nchilds; j++)// this loop retrieves cell data\n\t\t\t{\n\t\t\t\tvar cell_data = getCellText(cell[j]).toLowerCase();\n\t\t\t\tcell_value.push(cell_data);\n\t\t\t\t\n\t\t\t\tif(SearchArgs[j]!=\"\")\n\t\t\t\t{\n\t\t\t\t\tvar num_cell_data = parseFloat(cell_data);\n\t\t\t\t\t\n\t\t\t\t\tif(/<=/.test(SearchArgs[j]) && !isNaN(num_cell_data)) // first checks if there is an operator (<,>,<=,>=)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum_cell_data <= parseFloat(SearchArgs[j].replace(/<=/,\"\")) ? occurence[j] = true : occurence[j] = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse if(/>=/.test(SearchArgs[j]) && !isNaN(num_cell_data))\n\t\t\t\t\t{\n\t\t\t\t\t\tnum_cell_data >= parseFloat(SearchArgs[j].replace(/>=/,\"\")) ? occurence[j] = true : occurence[j] = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse if(/</.test(SearchArgs[j]) && !isNaN(num_cell_data))\n\t\t\t\t\t{\n\t\t\t\t\t\tnum_cell_data < parseFloat(SearchArgs[j].replace(/</,\"\")) ? occurence[j] = true : occurence[j] = false;\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\telse if(/>/.test(SearchArgs[j]) && !isNaN(num_cell_data))\n\t\t\t\t\t{\n\t\t\t\t\t\tnum_cell_data > parseFloat(SearchArgs[j].replace(/>/,\"\")) ? occurence[j] = true : occurence[j] = false;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\telse \n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\t// Improved by Cedric Wartel (cwl)\n\t\t\t\t\t\t// automatic exact match for selects and special characters are now filtered\n\t\t\t\t\t\t// modif cwl : exact match automatique sur les select\n\t\t\t\t\t\tvar regexp;\n\t\t\t\t\t\tif(ematch || fprops[\"col_\"+j]==\"select\") regexp = new RegExp(\'(^)\'+regexpEscape(SearchArgs[j])+\'($)\',\"gi\");\n\t\t\t\t\t\telse regexp = new RegExp(regexpEscape(SearchArgs[j]),\"gi\");\n\t\t\t\t\t\toccurence[j] = regexp.test(cell_data);\n\t\t\t\t\t}\n\t\t\t\t}//if SearchArgs\n\t\t\t}//for j\n\t\t\t\n\t\t\tfor(var z=0; z<ncells; z++)\n\t\t\t{\n\t\t\t\tif(SearchArgs[z]!=\"\" && !occurence[z]) isRowValid = false;\n\t\t\t}//for t\n\t\t\t\n\t\t}//if\n\t\t\n\t\tif(!isRowValid)\n\t\t{ \n\t\t\trow[k].style.display = \"none\"; hiddenrows++; \n\t\t\tif( showPaging ) row[k].setAttribute(\"validRow\",\"false\");\n\t\t} else {\n\t\t\trow[k].style.display = \"\"; \n\t\t\tif( showPaging ) row[k].setAttribute(\"validRow\",\"true\");\n\t\t}\n\t\t\n\t}// for k\n\t\n\tt.tf_nRows = parseInt( getRowsNb(id) )-hiddenrows;\n\tif( !showPaging ) applyFilterProps(id);//applies filter props after filtering process\n\tif( showPaging ){ t.tf_startPagingRow=0; setPagingInfo(id); }//starts paging process\t\n}\n\nfunction setPagingInfo(id)\n/*====================================================\n\t- Paging fn\n\t- calculates page # according to valid rows\n\t- refreshes paging select according to page #\n\t- Calls GroupByPage fn\n=====================================================*/\n{\t\n\tvar t = grabEBI(id);\n\tvar start_row = parseInt( t.tf_ref_row );//filter start row\n\tvar pagelength = t.tf_pagingLength;\n\tvar row = grabTag(t,\"tr\");\t\n\tvar mdiv = grabEBI(\"mdiv_\"+id);\n\tvar slcPages = grabEBI(\"slcPages_\"+id);\n\tvar pgspan = grabEBI(\"pgspan_\"+id);\n\tvar nrows = 0;\n\t\n\tfor(var j=start_row; j<row.length; j++)//counts rows to be grouped \n\t{\n\t\tif(row[j].getAttribute(\"validRow\") == \"true\") nrows++;\n\t}//for j\n\t\n\tvar npg = Math.ceil( nrows/pagelength );//calculates page nb\n\tpgspan.innerHTML = npg; //refresh page nb span \n\tslcPages.innerHTML = \"\";//select clearing shortcut\n\t\n\tif( npg>0 )\n\t{\n\t\tmdiv.style.visibility = \"visible\";\n\t\tfor(var z=0; z<npg; z++)\n\t\t{\n\t\t\tvar currOpt = new Option((z+1),z*pagelength,false,false);\n\t\t\tslcPages.options[z] = currOpt;\n\t\t}\n\t} else {/*** if no results paging select is hidden ***/\n\t\tmdiv.style.visibility = \"hidden\";\n\t}\n\t\n\tGroupByPage(id);\n}\n\nfunction GroupByPage(id)\n/*====================================================\n\t- Paging fn\n\t- Displays current page rows\n=====================================================*/\n{\n\tshowLoader(id,\"\");\n\tvar t = grabEBI(id);\n\tvar start_row = parseInt( t.tf_ref_row );//filter start row\n\tvar pagelength = parseInt( t.tf_pagingLength );\n\tvar paging_start_row = parseInt( t.tf_startPagingRow );//paging start row\n\tvar paging_end_row = paging_start_row + pagelength;\n\tvar row = grabTag(t,\"tr\");\n\tvar nrows = 0;\n\tvar validRows = new Array();//stores valid rows index\n\t\n\tfor(var j=start_row; j<row.length; j++)\n\t//this loop stores valid rows index in validRows Array\n\t{\n\t\tvar isRowValid = row[j].getAttribute(\"validRow\");\n\t\tif(isRowValid==\"true\") validRows.push(j);\n\t}//for j\n\n\tfor(h=0; h<validRows.length; h++)\n\t//this loop shows valid rows of current page\n\t{\n\t\tif( h>=paging_start_row && h<paging_end_row )\n\t\t{\n\t\t\tnrows++;\n\t\t\trow[ validRows[h] ].style.display = \"\";\n\t\t} else row[ validRows[h] ].style.display = \"none\";\n\t}//for h\n\t\n\tt.tf_nRows = parseInt(nrows);\n\tapplyFilterProps(id);//applies filter props after filtering process\n}\n\nfunction applyFilterProps(id)\n/*====================================================\n\t- checks fns that should be called\n\tafter filtering and/or paging process\n=====================================================*/\n{\n\tt = grabEBI(id);\n\tvar rowsCounter = t.tf_rowsCounter;\n\tvar nRows = t.tf_nRows;\n\tvar rowVisibility = t.tf_rowVisibility;\n\tvar alternateRows = t.tf_alternateBgs;\n\tvar colOperation = t.tf_colOperation;\n\t\n\tif( rowsCounter ) showRowsCounter( id,parseInt(nRows) );//refreshes rows counter\n\tif( rowVisibility ) setVisibleRows(id);//shows rows always visible\n\tif( alternateRows ) setAlternateRows(id);//alterning row colors\n\tif( colOperation  ) setColOperation(id);//makes operation on a col\n\tshowLoader(id,\"none\");\n}\n\nfunction hasGrid(id)\n/*====================================================\n\t- checks if table has a filter grid\n\t- returns a boolean\n=====================================================*/\n{\n\tvar r = false, t = grabEBI(id);\n\tif(t != null && t.nodeName.toLowerCase() == \"table\")\n\t{\n\t\tfor(i in TblId)\n\t\t{\n\t\t\tif(id == TblId[i]) r = true;\n\t\t}// for i\n\t}//if\n\treturn r;\n}\n\nfunction getCellsNb(id,nrow)\n/*====================================================\n\t- returns number of cells in a row\n\t- if nrow param is passed returns number of cells \n\tof that specific row\n=====================================================*/\n{\n  \tvar t = grabEBI(id);\n\tvar tr;\n\tif(nrow == undefined) tr = grabTag(t,\"tr\")[0];\n\telse  tr = grabTag(t,\"tr\")[nrow];\n\tvar n = getChildElms(tr);\n\treturn n.childNodes.length;\n}\n\nfunction getRowsNb(id)\n/*====================================================\n\t- returns total nb of filterable rows starting \n\tfrom reference row if defined\n=====================================================*/\n{\n\tvar t = grabEBI(id);\n\tvar s = t.tf_ref_row;\n\tvar ntrs = grabTag(t,\"tr\").length;\n\treturn parseInt(ntrs-s);\n}\n\nfunction getFilters(id)\n/*====================================================\n\t- returns an array containing filters ids\n\t- Note that hidden filters are also returned\n=====================================================*/\n{\n\tvar SearchFltId = new Array();\n\tvar t = grabEBI(id);\n\tvar tr = grabTag(t,\"tr\")[0];\n\tvar enfants = tr.childNodes;\n\tif(t.tf_fltGrid)\n\t{\n\t\tfor(var i=0; i<enfants.length; i++) \n\t\t\tSearchFltId.push(enfants[i].firstChild.getAttribute(\"id\"));\t\t\n\t}\n\treturn SearchFltId;\n}\n\nfunction clearFilters(id)\n/*====================================================\n\t- clears grid filters\n=====================================================*/\n{\n\tSearchFlt = getFilters(id);\n\tfor(i in SearchFlt) grabEBI(SearchFlt[i]).value = \"\";\n}\n\nfunction showLoader(id,p)\n/*====================================================\n\t- displays/hides loader div\n=====================================================*/\n{\n\tvar loader = grabEBI(\"load_\"+id);\n\tif(loader != null && p==\"none\")\n\t\tsetTimeout(\"grabEBI(\'load_\"+id+\"\').style.display = \'\"+p+\"\'\",150);\n\telse if(loader != null && p!=\"none\") loader.style.display = p;\n}\n\nfunction showRowsCounter(id,p)\n/*====================================================\n\t- Shows total number of filtered rows\n=====================================================*/\n{\n\tvar totrows = grabEBI(\"totrows_span_\"+id);\n\tif(totrows != null && totrows.nodeName.toLowerCase() == \"span\" ) \n\t\ttotrows.innerHTML = p;\n}\n\nfunction getChildElms(n)\n/*====================================================\n\t- checks passed node is a ELEMENT_NODE nodeType=1\n\t- removes TEXT_NODE nodeType=3  \n=====================================================*/\n{\n\tif(n.nodeType == 1)\n\t{\n\t\tvar enfants = n.childNodes;\n\t\tfor(var i=0; i<enfants.length; i++)\n\t\t{\n\t\t\tvar child = enfants[i];\n\t\t\tif(child.nodeType == 3) n.removeChild(child);\n\t\t}\n\t\treturn n;\t\n\t}\n}\n\nfunction getCellText(n)\n/*====================================================\n\t- returns text + text of child nodes of a cell\n=====================================================*/\n{\n\tvar s = \"\";\n\tvar enfants = n.childNodes;\n\tfor(var i=0; i<enfants.length; i++)\n\t{\n\t\tvar child = enfants[i];\n\t\tif(child.nodeType == 3) s+= child.data;\n\t\telse s+= getCellText(child);\n\t}\n\treturn s;\n}\n\nfunction getColValues(id,colindex,num)\n/*====================================================\n\t- returns an array containing cell values of\n\ta column\n\t- needs following args:\n\t\t- filter id (string)\n\t\t- column index (number)\n\t\t- a boolean set to true if we want only \n\t\tnumbers to be returned\n=====================================================*/\n{\n\tvar t = grabEBI(id);\n\tvar row = grabTag(t,\"tr\");\n\tvar nrows = row.length;\n\tvar start_row = parseInt( t.tf_ref_row );//filter start row\n\tvar ncells = getCellsNb( id,start_row );\n\tvar colValues = new Array();\n\t\n\tfor(var i=start_row; i<nrows; i++)//iterates rows\n\t{\n\t\tvar cell = getChildElms(row[i]).childNodes;\n\t\tvar nchilds = cell.length;\n\t\n\t\tif(nchilds == ncells)// checks if row has exact cell #\n\t\t{\n\t\t\tfor(var j=0; j<nchilds; j++)// this loop retrieves cell data\n\t\t\t{\n\t\t\t\tif(j==colindex && row[i].style.display==\"\" )\n\t\t\t\t{\n\t\t\t\t\tvar cell_data = getCellText( cell[j] ).toLowerCase();\n\t\t\t\t\t(num) ? colValues.push( parseFloat(cell_data) ) : colValues.push( cell_data );\n\t\t\t\t}//if j==k\n\t\t\t}//for j\n\t\t}//if nchilds == ncells\n\t}//for i\n\treturn colValues;\t\n}\n\nfunction setColWidths(id)\n/*====================================================\n\t- sets widths of columns\n=====================================================*/\n{\n\tif( hasGrid(id) )\n\t{\n\t\tvar t = grabEBI(id);\n\t\tt.style.tableLayout = \"fixed\";\n\t\tvar colWidth = t.tf_colWidth;\n\t\tvar start_row = parseInt( t.tf_ref_row );//filter start row\n\t\tvar row = grabTag(t,\"tr\")[0];\n\t\tvar ncells = getCellsNb(id,start_row);\n\t\tfor(var i=0; i<colWidth.length; i++)\n\t\t{\n\t\t\tfor(var k=0; k<ncells; k++)\n\t\t\t{\n\t\t\t\tcell = row.childNodes[k];\n\t\t\t\tif(k==i) cell.style.width = colWidth[i];\n\t\t\t}//var k\n\t\t}//for i\n\t}//if hasGrid\n}\n\nfunction setVisibleRows(id)\n/*====================================================\n\t- makes a row always visible\n=====================================================*/\n{\n\tif( hasGrid(id) )\n\t{\n\t\tvar t = grabEBI(id);\t\t\n\t\tvar row = grabTag(t,\"tr\");\n\t\tvar nrows = row.length;\n\t\tvar showPaging = t.tf_displayPaging;\n\t\tvar visibleRows = t.tf_rowVisibility;\n\t\tfor(var i=0; i<visibleRows.length; i++)\n\t\t{\n\t\t\tif(visibleRows[i]<=nrows)//row index cannot be > nrows\n\t\t\t{\n\t\t\t\tif(showPaging)\n\t\t\t\t\trow[ visibleRows[i] ].setAttribute(\"validRow\",\"true\");\n\t\t\t\trow[ visibleRows[i] ].style.display = \"\";\n\t\t\t}//if\n\t\t}//for i\n\t}//if hasGrid\n}\n\nfunction setAlternateRows(id)\n/*====================================================\n\t- alternates row colors for better readability\n=====================================================*/\n{\n\tif( hasGrid(id) )\n\t{\n\t\tvar t = grabEBI(id);\t\t\n\t\tvar row = grabTag(t,\"tr\");\n\t\tvar nrows = row.length;\n\t\tvar start_row = parseInt( t.tf_ref_row );//filter start row\n\t\tvar visiblerows = new Array();\n\t\tfor(var i=start_row; i<nrows; i++)//visible rows are stored in visiblerows array\n\t\t\tif( row[i].style.display==\"\" ) visiblerows.push(i);\n\t\t\n\t\tfor(var j=0; j<visiblerows.length; j++)//alternates bg color\n\t\t\t(j % 2 == 0) ? row[ visiblerows[j] ].className = \"even\" : row[ visiblerows[j] ].className = \"odd\";\n\t\t\n\t}//if hasGrid\n}\n\nfunction setColOperation(id)\n/*====================================================\n\t- Calculates values of a column\n\t- params are stored in \'colOperation\' table\'s\n\tattribute\n\t\t- colOperation[\"id\"] contains ids of elements \n\t\tshowing result (array)\n\t\t- colOperation[\"col\"] contains index of \n\t\tcolumns (array)\n\t\t- colOperation[\"operation\"] contains operation\n\t\ttype (array, values: sum, mean)\n\t\t- colOperation[\"write_method\"] array defines \n\t\twhich method to use for displaying the \n\t\tresult (innerHTML, setValue, createTextNode).\n\t\tNote that innerHTML is the default value.\n\t\t\n\t!!! to be optimised\n=====================================================*/\n{\n\tif( hasGrid(id) )\n\t{\n\t\tvar t = grabEBI(id);\n\t\tvar labelId = t.tf_colOperation[\"id\"];\n\t\tvar colIndex = t.tf_colOperation[\"col\"];\n\t\tvar operation = t.tf_colOperation[\"operation\"];\n\t\tvar outputType =  t.tf_colOperation[\"write_method\"];\n\t\tvar precision = 2;//decimal precision\n\t\t\n\t\tif( (typeof labelId).toLowerCase()==\"object\" \n\t\t\t&& (typeof colIndex).toLowerCase()==\"object\" \n\t\t\t&& (typeof operation).toLowerCase()==\"object\" )\n\t\t{\n\t\t\tvar row = grabTag(t,\"tr\");\n\t\t\tvar nrows = row.length;\n\t\t\tvar start_row = parseInt( t.tf_ref_row );//filter start row\n\t\t\tvar ncells = getCellsNb( id,start_row );\n\t\t\tvar colvalues = new Array();\n\t\t\t\t\t\t\n\t\t\tfor(var k=0; k<colIndex.length; k++)//this retrieves col values\n\t\t\t{\n\t\t\t\tcolvalues.push( getColValues(id,colIndex[k],true) );\t\t\t\n\t\t\t}//for k\n\t\t\t\n\t\t\tfor(var i=0; i<colvalues.length; i++)\n\t\t\t{\n\t\t\t\tvar result=0, nbvalues=0;\n\t\t\t\tfor(var j=0; j<colvalues[i].length; j++ )\n\t\t\t\t{\n\t\t\t\t\tvar cvalue = colvalues[i][j];\n\t\t\t\t\tif( !isNaN(cvalue) )\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch( operation[i].toLowerCase() )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase \"sum\":\n\t\t\t\t\t\t\t\tresult += parseFloat( cvalue );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"mean\":\n\t\t\t\t\t\t\t\tnbvalues++;\n\t\t\t\t\t\t\t\tresult += parseFloat( cvalue );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t//add cases for other operations\n\t\t\t\t\t\t}//switch\n\t\t\t\t\t}\n\t\t\t\t}//for j\n\t\t\t\t\n\t\t\t\tswitch( operation[i].toLowerCase() )\n\t\t\t\t{\n\t\t\t\t\tcase \"mean\":\n\t\t\t\t\t\tresult = result/nbvalues;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(outputType != undefined && (typeof outputType).toLowerCase()==\"object\")\n\t\t\t\t//if outputType is defined\n\t\t\t\t{\n\t\t\t\t\tresult = result.toFixed( precision );\n\t\t\t\t\tif( grabEBI( labelId[i] )!=undefined )\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch( outputType[i].toLowerCase() )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase \"innerhtml\":\n\t\t\t\t\t\t\t\tgrabEBI( labelId[i] ).innerHTML = result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"setvalue\":\n\t\t\t\t\t\t\t\tgrabEBI( labelId[i] ).value = result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"createtextnode\":\n\t\t\t\t\t\t\t\tvar oldnode = grabEBI( labelId[i] ).firstChild;\n\t\t\t\t\t\t\t\tvar txtnode = createText( result );\n\t\t\t\t\t\t\t\tgrabEBI( labelId[i] ).replaceChild( txtnode,oldnode );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t//other cases could be added\n\t\t\t\t\t\t}//switch\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tgrabEBI( labelId[i] ).innerHTML = result.toFixed( precision );\n\t\t\t\t\t} catch(e){ }//catch\n\t\t\t\t}//else\n\t\t\t\t\n\t\t\t}//for i\n\n\t\t}//if typeof\n\t}//if hasGrid\n}\n\nfunction grabEBI(id)\n/*====================================================\n\t- this is just a getElementById shortcut\n=====================================================*/\n{\n\treturn document.getElementById( id );\n}\n\nfunction grabTag(obj,tagname)\n/*====================================================\n\t- this is just a getElementsByTagName shortcut\n=====================================================*/\n{\n\treturn obj.getElementsByTagName( tagname );\n}\n\nfunction regexpEscape(s)\n/*====================================================\n\t- escapes special characters [\\^$.|?*+() \n\tfor regexp\n\t- Many thanks to Cedric Wartel for this fn\n=====================================================*/\n{\n\t// traite les caract\u00e8res sp\u00e9ciaux [\\^$.|?*+()\n\t//remplace le carct\u00e8re c par \\c\n\tfunction escape(e)\n\t{\n\t\ta = new RegExp(\'\\\\\'+e,\'g\');\n\t\ts = s.replace(a,\'\\\\\'+e);\n\t}\n\n\tchars = new Array(\'\\\\\',\'[\',\'^\',\'$\',\'.\',\'|\',\'?\',\'*\',\'+\',\'(\',\')\');\n\t//chars.each(escape); // no prototype framework here...\n\tfor(e in chars) escape(chars[e]);\n\treturn s;\n}\n\nfunction createElm(elm)\n/*====================================================\n\t- returns an html element with its attributes\n\t- accepts the following params:\n\t\t- a string defining the html element \n\t\tto create\n\t\t- an undetermined # of arrays containing the\n\t\tcouple \"attribute name\",\"value\" [\"id\",\"myId\"]\n=====================================================*/\n{\n\tvar el = document.createElement( elm );\t\t\n\tif(arguments.length>1)\n\t{\n\t\tfor(var i=0; i<arguments.length; i++)\n\t\t{\n\t\t\tvar argtype = typeof arguments[i];\n\t\t\tswitch( argtype.toLowerCase() )\n\t\t\t{\n\t\t\t\tcase \"object\":\n\t\t\t\t\tif( arguments[i].length==2 )\n\t\t\t\t\t{\t\t\t\t\t\t\t\n\t\t\t\t\t\tel.setAttribute( arguments[i][0],arguments[i][1] );\n\t\t\t\t\t}//if array length==2\n\t\t\t\tbreak;\n\t\t\t}//switch\n\t\t}//for i\n\t}//if args\n\treturn el;\t\n}\n\nfunction createText(node)\n/*====================================================\n\t- this is just a document.createTextNode shortcut\n=====================================================*/\n{\n\treturn document.createTextNode( node );\n}\n\nfunction DetectKey(e)\n/*====================================================\n\t- common fn that detects return key for a given\n\telement (onkeypress attribute on input)\n=====================================================*/\n{\n\tvar evt=(e)?e:(window.event)?window.event:null;\n\tif(evt)\n\t{\n\t\tvar key=(evt.charCode)?evt.charCode:\n\t\t\t((evt.keyCode)?evt.keyCode:((evt.which)?evt.which:0));\n\t\tif(key==\"13\")\n\t\t{\n\t\t\tvar cid, leftstr, tblid, CallFn, Match;\t\t\n\t\t\tcid = this.getAttribute(\"id\");\n\t\t\tleftstr = this.getAttribute(\"id\").split(\"_\")[0];\n\t\t\ttblid = cid.substring(leftstr.length+1,cid.length);\n\t\t\tt = grabEBI(tblid);\n\t\t\t(t.tf_isModfilter_fn) ? t.tf_modfilter_fn.call() : Filter(tblid);\n\t\t}//if key\n\t}//if evt\t\n}\n\nfunction importScript(scriptName,scriptPath)\n{\n\tvar isImported = false; \n\tvar scripts = grabTag(document,\"script\");\n\n\tfor (var i=0; i<scripts.length; i++)\n\t{\n\t\tif(scripts[i].src.match(scriptPath))\n\t\t{ \n\t\t\tisImported = true;\t\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif( !isImported )//imports script if not available\n\t{\n\t\tvar head = grabTag(document,\"head\")[0];\n\t\tvar extScript = createElm(\t\"script\",\n\t\t\t\t\t\t\t\t\t[\"id\",scriptName],\n\t\t\t\t\t\t\t\t\t[\"type\",\"text/javascript\"],\n\t\t\t\t\t\t\t\t\t[\"src\",scriptPath]\t);\n\t\thead.appendChild(extScript);\n\t}\n}//fn importScript\n\n\n\n/*====================================================\n\t- Below a collection of public functions \n\tfor developement purposes\n\t- all public methods start with prefix \'TF_\'\n\t- These methods can be removed safely if not\n\tneeded\n=====================================================*/\n\nfunction TF_GetFilterIds()\n/*====================================================\n\t- returns an array containing filter grids ids\n=====================================================*/\n{\n\ttry{ return TblId }\n\tcatch(e){ alert(\'TF_GetFilterIds() fn: could not retrieve any ids\'); }\n}\n\nfunction TF_HasGrid(id)\n/*====================================================\n\t- checks if table has a filter grid\n\t- returns a boolean\n=====================================================*/\n{\n\treturn hasGrid(id);\n}\n\nfunction TF_GetFilters(id)\n/*====================================================\n\t- returns an array containing filters ids of a\n\tspecified grid\n=====================================================*/\n{\n\ttry\n\t{\n\t\tvar flts = getFilters(id);\n\t\treturn flts;\n\t} catch(e) {\n\t\talert(\'TF_GetFilters() fn: table id not found\');\n\t}\n\t\n}\n\nfunction TF_GetStartRow(id)\n/*====================================================\n\t- returns starting row index for filtering\n\tprocess\n=====================================================*/\n{\n\ttry\n\t{\n\t\tvar t = grabEBI(id);\n\t\treturn t.tf_ref_row;\n\t} catch(e) {\n\t\talert(\'TF_GetStartRow() fn: table id not found\');\n\t}\n}\n\nfunction TF_GetColValues(id,colindex,num)\n/*====================================================\n\t- returns an array containing cell values of\n\ta column\n\t- needs following args:\n\t\t- filter id (string)\n\t\t- column index (number)\n\t\t- a boolean set to true if we want only \n\t\tnumbers to be returned\n=====================================================*/\n{\n\tif( hasGrid(id) )\n\t{\n\t\treturn getColValues(id,colindex,num);\n\t}//if TF_HasGrid\n\telse alert(\'TF_GetColValues() fn: table id not found\');\n}\n\nfunction TF_Filter(id)\n/*====================================================\n\t- filters a table\n=====================================================*/\n{\n\tvar t = grabEBI(id);\n\tif( TF_HasGrid(id) ) Filter(id);\n\telse alert(\'TF_Filter() fn: table id not found\');\n}\n\nfunction TF_RemoveFilterGrid(id)\n/*====================================================\n\t- removes a filter grid\n=====================================================*/\n{\n\tif( TF_HasGrid(id) )\n\t{\n\t\tvar t = grabEBI(id);\n\t\tclearFilters(id);\n\t\t\t\t\n\t\tif(grabEBI(\"inf_\"+id)!=null)\n\t\t{\n\t\t\tt.parentNode.removeChild(t.previousSibling);\n\t\t}\n\t\t// remove paging here\n\t\tvar row = grabTag(t,\"tr\");\n\t\t\n\t\tfor(var j=0; j<row.length; j++)\n\t\t//this loop shows all rows and removes validRow attribute\n\t\t{\t\t\t\n\t\t\trow[j].style.display = \"\";\n\t\t\ttry\n\t\t\t{ \n\t\t\t\tif( row[j].hasAttribute(\"validRow\") ) \n\t\t\t\t\trow[j].removeAttribute(\"validRow\");\n\t\t\t} //ie<=6 doesn\'t support hasAttribute method\n\t\t\tcatch(e){\n\t\t\t\tfor( var x = 0; x < row[j].attributes.length; x++ ) \n\t\t\t\t{\n\t\t\t\t\tif( row[j].attributes[x].nodeName.toLowerCase()==\"validrow\" ) \n\t\t\t\t\t\trow[j].removeAttribute(\"validRow\");\n\t\t\t\t}//for x\n\t\t\t}//catch(e)\n\t\t}//for j\t\t\n\t\t\n\t\tif( t.tf_alternateBgs )//removes alterning row colors\n\t\t{\n\t\t\tfor(var k=0; k<row.length; k++)\n\t\t\t//this loop removes bg className\n\t\t\t{\n\t\t\t\trow[k].className = \"\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(t.tf_fltGrid) t.deleteRow(0);\n\t\tfor(i in TblId)//removes grid id value from array\n\t\t\tif(id == TblId[i]) TblId.splice(i,1);\n\t\t\n\t}//if TF_HasGrid\n\telse alert(\'TF_RemoveFilterGrid() fn: table id not found\');\n}\n\nfunction TF_ClearFilters(id)\n/*====================================================\n\t- clears grid filters only, table is not filtered\n=====================================================*/\n{\n\tif( TF_HasGrid(id) ) clearFilters(id);\n\telse alert(\'TF_ClearFilters() fn: table id not found\');\n}\n\nfunction TF_SetFilterValue(id,index,searcharg)\n/*====================================================\n\t- Inserts value in a specified filter\n\t- Params:\n\t\t- id: table id (string)\n\t\t- index: filter column index (numeric value)\n\t\t- searcharg: search string\n=====================================================*/\n{\n\tif( TF_HasGrid(id) )\n\t{\n\t\tvar flts = getFilters(id);\n\t\tfor(i in flts)\n\t\t{\n\t\t\tif( i==index ) grabEBI(flts[i]).value = searcharg;\n\t\t}\n\t} else {\n\t\talert(\'TF_SetFilterValue() fn: table id not found\');\n\t}\n}\n\n\n\n\n/*====================================================\n\t- bind an external script fns\n\t- fns below do not belong to filter grid script \n\tand are used to interface with external \n\tautocomplete script found at the following URL:\n\thttp://www.codeproject.com/jscript/jsactb.asp\n\t(credit to zichun) \n\t- fns used to merge filter grid with external\n\tscripts\n=====================================================*/\nvar colValues = new Array();\n\nfunction setAutoComplete(id)\n{\n\tvar t = grabEBI(id);\n\tvar bindScript = t.tf_bindScript;\n\tvar scriptName = bindScript[\"name\"];\n\tvar scriptPath = bindScript[\"path\"];\n\tinitAutoComplete();\n\t\n\tfunction initAutoComplete()\n\t{\n\t\tvar filters = TF_GetFilters(id);\n\t\tfor(var i=0; i<filters.length; i++)\n\t\t{\n\t\t\tif( grabEBI(filters[i]).nodeName.toLowerCase()==\"input\")\n\t\t\t{\n\t\t\t\tcolValues.push( getColValues(id,i) );\t\n\t\t\t} else colValues.push( \'\' );\n\t\t}//for i\n\n\t\ttry{ actb( grabEBI(filters[0]), colValues[0] ); }\n\t\tcatch(e){ alert(scriptPath + \" script may not be loaded\"); }\n\n\t}//fn\n}");
            localPrintWriter.close();
        } catch (FileNotFoundException localFileNotFoundException) {
            localFileNotFoundException.printStackTrace();
        }
    }

    public static void pieChartJS(int paramInt1, int paramInt2, int paramInt3, int paramInt4) {
        try {
            PrintWriter localPrintWriter = new PrintWriter(
                    Directory.RESULTSDir + Directory.SEP + Directory.RUN_PREFIX + paramInt4 + Directory.SEP + "pieChart.js");
            localPrintWriter.println("$(document).ready(function() {\n    var data = [['" + ReportLabels.PASS.getLabel() + "', "
                    + paramInt1 + "], ['" + ReportLabels.FAIL.getLabel() + "', " + paramInt2 + "], ['"
                    + ReportLabels.SKIP.getLabel() + "', " + paramInt3 + "]];\n" + "jQuery.jqplot('chart', [data],\n"
                    + "{seriesColors: [\"" + Colors.PASS.getColor() + "\", \"" + Colors.FAIL.getColor() + "\", \""
                    + Colors.SKIP.getColor() + "\"],\n" + "seriesDefaults: {\n" + "// Make this a pie chart.\n"
                    + "renderer: jQuery.jqplot.PieRenderer,\n" + "rendererOptions: {\n" + "padding: 15,\n" + "sliceMargin: 1,\n"
                    + "// Put data labels on the pie slices.\n" + "// By default, labels show the percentage of the slice.\n"
                    + "showDataLabels: true\n" + "}\n" + "},\n" + "grid: {borderColor: '#cccccc', background: '#ffffff',\n"
                    + "borderWidth: 0, // pixel width of border around grid.\n" + "shadow: false // draw a shadow for grid.\n"
                    + "},\n" + "legend: {show: true, location: 'e'}\n" + "}\n" + ");\n" + "});");
            localPrintWriter.close();
        } catch (FileNotFoundException localFileNotFoundException) {
            localFileNotFoundException.printStackTrace();
        }
    }

    public static void barChartJS(String paramString1, String paramString2, String paramString3, int paramInt) {
        paramString1 = paramString1.substring(0, paramString1.lastIndexOf(';')).replace(';', ',').trim();
        paramString2 = paramString2.substring(0, paramString2.lastIndexOf(';')).replace(';', ',').trim();
        paramString3 = paramString3.substring(0, paramString3.lastIndexOf(';')).replace(';', ',').trim();
        int max = getMax(getMax(paramString1) + "," + getMax(paramString2) + "," + getMax(paramString3));
        int yAxisTickInterval = (int) Math.max(1, Math.pow(10, (String.valueOf(max).length() - 1)));
        int i = 0;
        if (paramInt > 10) {
            i = paramInt - 10;
            paramString1 = reduceData(paramString1, i);
            paramString2 = reduceData(paramString2, i);
            paramString3 = reduceData(paramString3, i);
        }
        try {
            PrintWriter localPrintWriter = new PrintWriter(Directory.RESULTSDir + Directory.SEP + "barChart.js");
            localPrintWriter.println("            $(document).ready(function(){\n                var s1 = [" + paramString1
                    + "];\n" + "var s2 = [" + paramString2 + "];\n" + "var s3 = [" + paramString3 + "];\n");
            localPrintWriter.print("var ticks = [");
            for (int j = i + 1; j <= paramInt; j++) {
                localPrintWriter.print(j);
                if (j != paramInt) {
                    localPrintWriter.print(",");
                }
            }
            localPrintWriter.print("];");
            localPrintWriter.println(
                    "    $.jqplot('bar', [s1, s2, s3], {\n        animate: true,axesDefaults:{min:0},        seriesColors: [\""
                            + Colors.PASS.getColor() + "\", \"" + Colors.FAIL.getColor() + "\", \"" + Colors.SKIP.getColor()
                            + "\"],\n" + "stackSeries: false,\n" + "seriesDefaults: {\n" + "renderer: $.jqplot.BarRenderer,\n"
                            + "pointLabels: {show: true}\n"
                            + ", rendererOptions: {barWidth: 25, barMargin: 25, fillToZero: true}\n" + "}\n" + ",\n"
                            + "grid: {borderColor: '#ffffff', background: '#ffffff',\n"
                            + "borderWidth: 0.5, // pixel width of border around grid.\n"
                            + "shadow: false // draw a shadow for grid.\n" + "}\n" + ",\n" + "legend: {\n" + "show: true,\n"
                            + "location: 'e',\n" + "placement: 'outside',\n" + "labels: ['" + ReportLabels.PASS.getLabel()
                            + "', '" + ReportLabels.FAIL.getLabel() + "', '" + ReportLabels.SKIP.getLabel() + "']\n" + "},\n"
                            + "axes: {\n" + "xaxis: {\n" + "renderer: $.jqplot.CategoryAxisRenderer,\n" + "ticks: ticks,\n"
                            + "label: \"" + ReportLabels.X_AXIS.getLabel() + "\"\n" + "}\n" + ",\n" + "yaxis: {\n" + "label: \""
                            + ReportLabels.Y_AXIS.getLabel() + "\",\n" + "tickOptions: {\n" + "formatString: \"%dtc\"\n"
                            + ",tickInterval: " + yAxisTickInterval + "\n" + "}\n" + "}\n" + "}\n" + "});\n" + "});");
            localPrintWriter.close();
        } catch (FileNotFoundException localFileNotFoundException) {
            localFileNotFoundException.printStackTrace();
        }
    }

    public static void lineChartJS(String paramString1, String paramString2, String paramString3, int paramInt) {
        paramString1 = paramString1.substring(0, paramString1.lastIndexOf(';')).replace(';', ',').trim();
        paramString2 = paramString2.substring(0, paramString2.lastIndexOf(';')).replace(';', ',').trim();
        paramString3 = paramString3.substring(0, paramString3.lastIndexOf(';')).replace(';', ',').trim();

        int max = getMax(getMax(paramString1) + "," + getMax(paramString2) + "," + getMax(paramString3));
        int yAxisTickInterval = (int) Math.max(1, Math.pow(10, (String.valueOf(max).length() - 1)));

        try {
            PrintWriter localPrintWriter = new PrintWriter(Directory.RESULTSDir + Directory.SEP + "lineChart.js");
            localPrintWriter.println("            $(document).ready(function(){\n                var line1 = [" + paramString1
                    + "];\n" + "var line2 = [" + paramString2 + "];\n" + "var line3 = [" + paramString3 + "];\n");
            localPrintWriter.print("var ticks = [");
            int i = 1;
            if (paramInt == 1) {
                i = 0;
            }
            for (int j = i; j <= paramInt; j++) {
                localPrintWriter.print(j);
                if (j != paramInt) {
                    localPrintWriter.print(",");
                }
            }
            localPrintWriter.print("];");
            localPrintWriter
                    .print("$.jqplot('line', [line1, line2, line3], {\n        animate: true,\naxesDefaults:{min:0},        seriesDefaults: {\n            rendererOptions: {\n                smooth: true\n            }\n        },\n        series: [{lineWidth: 1.5, label: '"
                            + ReportLabels.PASS.getLabel() + "'},\n" + "{lineWidth: 1.5, label: '" + ReportLabels.FAIL.getLabel()
                            + "'},\n" + "{lineWidth: 1.5, label: '" + ReportLabels.SKIP.getLabel() + "'}],\n" + "axes: {\n"
                            + "xaxis: {\n" + "label: \"" + ReportLabels.X_AXIS.getLabel() + "\",\n" + "ticks: ticks,\n"
                            + "tickOptions: {\n");
            if (paramInt <= 10) {
                localPrintWriter.print("                    formatString: \"%'d Run\"\n");
            } else {
                localPrintWriter.print("                    formatString: \"%'d \"\n");
            }

            localPrintWriter
                    .print("                },\n                pad: 1.2,\n                rendererOptions: {\n                    tickInset: 0.3,\n                    minorTicks: 1\n                }\n            },\n            yaxis: {\n                label: \""
                            + ReportLabels.Y_AXIS.getLabel() + "\"\n" + ",tickInterval: " + yAxisTickInterval + "\n" + "}\n"
                            + "},\n" + "highlighter: {\n" + "show: true,\n" + "sizeAdjust: 10,\n" + "tooltipLocation: 'n',\n"
                            + "tooltipAxes: 'y',\n" + "tooltipFormatString: '%d :&nbsp;<b><i><span style=\"color:black;\">"
                            + ReportLabels.LINE_CHART_TOOLTIP.getLabel() + "</span></i></b>',\n" + "useAxesFormatters: false\n"
                            + "},\n" + "cursor: {\n" + "show: true\n" + "},\n"
                            + "grid: {background: '#ffffff', drawGridLines: true, gridLineColor: '#cccccc', borderColor: '#cccccc',\n"
                            + "borderWidth: 0.5, shadow: false},\n"
                            + "legend: {show: true, placement: 'outside', location: 'e'},\n" + "seriesColors: [\""
                            + Colors.PASS.getColor() + "\", \"" + Colors.FAIL.getColor() + "\", \"" + Colors.SKIP.getColor()
                            + "\"]\n" + "});\n" + "});\n" + "");
            localPrintWriter.close();
        } catch (FileNotFoundException localFileNotFoundException) {
            localFileNotFoundException.printStackTrace();
        }
    }

    private static int getMax(String paramString1) {
        int max = 0;
        for (String a : paramString1.split(",")) {
            int num = Integer.parseInt(a);
            max = num > max ? num : max;
        }
        return max;
    }
}
